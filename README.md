# CatsApp

## Getting starter

First clone this repo and install dependencies with:

```sh
git clone git@github.com:nicoandresr/cats-breeds.git
cd cats-breeds
npm i
```

Run the Prisma database migration to create the Cats database in SQLite.

```sh
npx nx prisma-migrate cats-db
```

Build the 3 projects with

```sh
npx nx run-many --target=build
```

Run all projects:

```sh
npx nx run-many --target=serve
```

## Architectural desitions

### NX mono-repo setup
I choose a mono-repo setup because it:
- Shared code and visibility - Keeps your code DRY across your entire organization. Reuse validation code, UI components, and types across the codebase. Reuse code between the backend, the frontend, and utility libraries.

- Atomic changes - Change a server API and modify the downstream applications that consume that API in the same commit. You can change a button component in a shared library and the applications that use that component in the same commit. A monorepo saves the pain of trying to coordinate commits across multiple repositories.

- Developer mobility - Get a consistent way of building and testing applications written using different tools and technologies. Developers can confidently contribute to other teams’ applications and verify that their changes are safe.

- Single set of dependencies - Use a single version of all third-party dependencies, reducing inconsistencies between applications. Less actively developed applications are still kept up-to-date with the latest version of a framework, library, or build tool.

<a href="https://nx.dev" target="_blank" rel="noreferrer"><img src="https://raw.githubusercontent.com/nrwl/nx/master/images/nx-logo.png" width="45"></a>

✨ **This workspace has been generated by [Nx, a Smart, fast and extensible build system.](https://nx.dev)** ✨

#### Understand this workspace

Run `nx graph` to see a diagram of the dependencies of the projects.

#### Remote caching

Run `npx nx connect-to-nx-cloud` to enable [remote caching](https://nx.app) and make CI faster.

#### Further help

Visit the [Nx Documentation](https://nx.dev) to learn more.

## Cats API
I choose use GraphQL MESH in the Backend for the API, with mesh we can use the openapi specification from the CATS API and generate the schemas and resolvers for expose the data in a GraphQL server.

GraphQL Mesh is a framework to build GraphQL Gateways on top of GraphQL and non-GraphQL services (REST, gRPC, and more).

Many approaches exist to build a GraphQL Gateway:

    creating an Apollo Server with Apollo DataSource to query sub-services
    creating a GraphQL Gateway from scratch using GraphQL tools (ex: stitchSchemas())
    use Apollo Federation

Visit the [Mesh Documentation](https://the-guild.dev/graphql/mesh/docs) to learn more.

## Cats DB
I choose NESTJS to set a backend up for the cats database, this nestjs server uses PrismaJS to create a database in sqlite and exposes an openapi schema that is used by the Cats-API

## Cats UI
The cats front end app is a React app that uses:
- GraphQL ApolloCLient
- MaterialUI components
- React-Hook-Form

## Screenshoots

<img src="./assets/CatsApp Screen 1.png" alt="cats app home screen list of breeds" />

<img src="./assets/CatsApp Screen 2.png" alt="cats app cats screen list of cats " />

<img src="./assets/CatsApp Screen 3.png" alt="cats app cats edid a cat" />

<img src="./assets/CatsApp GraphQL.png" alt="cats api in graphql" />

<img src="./assets/CatsApp Swagger CatsDB.png" alt="cats db swagger" />
